











            break;
            perror("read");
            return -1;
        buffer[i++] = current_char;
        if (result < 0) {
        if (result == 0 || current_char == '\0') {
        int result = read(STDIN_FILENO, &current_char, 1);
        perror("dup2");
        perror("dup2");
        perror("write");
        return -1;
        return -1;
        return -1;
        }
        }
    // Close stdin
    // Close stdout
    // Close the original pipe file descriptor
    // Close the original pipe file descriptor
    // Duplicate pipe read end to stdout
    // Duplicate pipe write end to stdin
    // Write to stdout (which is now the pipe)
    buffer[i] = '\0';
    char current_char;
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(pipe_fd);
    close(pipe_fd);
    if (dup2(pipe_fd, STDIN_FILENO) == -1) {
    if (dup2(pipe_fd, STDOUT_FILENO) == -1) {
    if (result < 0) {
    int i = 0;
    int result = write(STDOUT_FILENO, buffer, strlen(buffer) + 1);
    return 0;
    return 0;
    return i;
    return result;
    while (i < max_size - 1) {
    }
    }
    }
    }
#include "utils.h"
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
int read_pipe(char *buffer, int max_size) {
int setup_pipe_read(int pipe_fd) {
int setup_pipe_write(int pipe_fd) {
int write_pipe(const char *buffer) {
}
}
}
}
